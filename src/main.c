

/* System Includes */
#include "stdio.h"
#include "stdlib.h"
#include <string.h>


/* From Cryptoauthlib */
#include "cryptoauthlib.h"

/* ESP32 specific */
#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "esp_wifi.h"
#include "esp_event_loop.h"
#include "esp_system.h"
#include "nvs_flash.h"

#include "sdkconfig.h" // generated by "make menuconfig"


//for heap calculating
#include "esp_heap_caps.h"


//for debug 

#define SDA_PIN2 GPIO_NUM_18
#define SCL_PIN2 GPIO_NUM_19


#define TAG "ECC608"

#define I2C_MASTER_ACK 0
#define I2C_MASTER_NACK 1


/* The examples use simple WiFi configuration that you can set via
   'make menuconfig'.
   If you'd rather not, just change the below entries to strings with
   the config you want - ie #define EXAMPLE_WIFI_SSID "mywifissid"
*/
#define EXAMPLE_WIFI_SSID ""
#define EXAMPLE_WIFI_PASS ""

/* FreeRTOS event group to signal when we are connected & ready to make a request */
static EventGroupHandle_t wifi_event_group;

/* The event group allows multiple bits for each event,
   but we only care about one event - are we connected
   to the AP with an IP? */
const int CONNECTED_BIT = BIT0;

static const char* global_prov_uri = "";
static const char* id_scope = "";

void i2c_master_init()
{

	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA_PIN2,
		.scl_io_num = SCL_PIN2,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.master.clk_speed = 100000
		};
			
	i2c_param_config(I2C_NUM_0 , &i2c_config);
	i2c_driver_install(I2C_NUM_0 , I2C_MODE_MASTER, 0, 0, 0);
}

void get_atecc608cfg(ATCAIfaceCfg *cfg)
{
                cfg->iface_type             = ATCA_I2C_IFACE;
                cfg->devtype                = ATECC608A;
                cfg->atcai2c.slave_address  = 0XC0;
                cfg->atcai2c.bus            = 1;
                cfg->atcai2c.baud           = 100000;
                cfg->wake_delay             = 1500;
                cfg->rx_retries             = 20;

return;
}

static esp_err_t event_handler(void *ctx, system_event_t *event)
{
    switch(event->event_id) {
    case SYSTEM_EVENT_STA_START:
        esp_wifi_connect();
        break;
    case SYSTEM_EVENT_STA_GOT_IP:
        xEventGroupSetBits(wifi_event_group, CONNECTED_BIT);
        break;
    case SYSTEM_EVENT_STA_DISCONNECTED:
        /* This is a workaround as ESP32 WiFi libs don't currently
           auto-reassociate. */
        esp_wifi_connect();
        xEventGroupClearBits(wifi_event_group, CONNECTED_BIT);
        break;
    default:
        break;
    }
    return ESP_OK;
}

static void initialise_wifi(void)
{
    tcpip_adapter_init();
    wifi_event_group = xEventGroupCreate();
    ESP_ERROR_CHECK( esp_event_loop_init(event_handler, NULL) );
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK( esp_wifi_init(&cfg) );
    ESP_ERROR_CHECK( esp_wifi_set_storage(WIFI_STORAGE_RAM) );
    wifi_config_t wifi_config = {
        .sta = {
            .ssid = EXAMPLE_WIFI_SSID,
            .password = EXAMPLE_WIFI_PASS,
        },
    };
    ESP_LOGI(TAG, "Setting WiFi configuration SSID %s...", wifi_config.sta.ssid);
    ESP_ERROR_CHECK( esp_wifi_set_mode(WIFI_MODE_STA) );
    ESP_ERROR_CHECK( esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config) );
    ESP_ERROR_CHECK( esp_wifi_start() );
}


extern int prov_dev_client_ll_sample_run(const char * global_prov_uri , const char * id_scope);

void azure_task(void *pvParameter)
{
    xEventGroupWaitBits(wifi_event_group, CONNECTED_BIT,
                        false, true, portMAX_DELAY);
    ESP_LOGI(TAG, "Connected to AP success!");

    prov_dev_client_ll_sample_run(global_prov_uri , id_scope);

    vTaskDelete(NULL);
}

void sysinit(void)
{

        ATCAIfaceCfg cfg = {
                .iface_type             = ATCA_I2C_IFACE,
                .devtype                = ATECC608A,
                .atcai2c.slave_address  = 0XC0,
                .atcai2c.bus            = 1,
                .atcai2c.baud           = 100000,
                .wake_delay             = 1500,
                .rx_retries             = 20
        };

    ATCA_STATUS status = atcab_init(&cfg);

    if (status != ATCA_SUCCESS) {
        ESP_LOGE(TAG, "atcab_init() failed with ret=0x%08d\r\n", status);
    }
	

    uint8_t rand_out[RANDOM_NUM_SIZE];
    status = atcab_random(rand_out);

    if (status != ATCA_SUCCESS) {
        ESP_LOGE(TAG, "atcab_random() failed with ret=0x%08d\r\n", status);
    }

    uint8_t serial[ATCA_SERIAL_NUM_SIZE];
    status = atcab_read_serial_number(serial);

    if (status != ATCA_SUCCESS) {
	ESP_LOGE(TAG, "atcab_read_serial_number() failed with ret=0x%08d/r/n", status);
    }

    
    uint8_t revision[INFO_SIZE];
    status = atcab_info(revision);

    if (status != ATCA_SUCCESS) {
	ESP_LOGE(TAG, "atcab_read_serial_number() failed with ret=0x%08d/r/n", status);
    }


    uint8_t config_data[ATCA_ECC_CONFIG_SIZE];
    status = atcab_read_config_zone(config_data);

    if (status != ATCA_SUCCESS) {
	ESP_LOGE(TAG, "atcab_read_config_zone() failed with ret=0x%08d/r/n", status);
    }
	

    	printf("Random Number:\n");

    for (int i = 0; i < 4; i++){
        for(int j = 0; j < 8; j++){
	     printf("%02x ", rand_out[i * 8 + j]);
        }
	printf("\n");	
    }

	printf("Serial Number:\n");

	for ( int i =0; i< 9; i++){
	    printf("%02x ", serial[i]);
        }
	   printf("\n");

	printf("Revision Number:\n");

	for ( int i =0; i< 4; i++){
	    printf("%02x ", revision[i]);
        }
        printf("\n");	

	printf("Config Zone data:\n");

        for (int i = 0; i < 16; i++){
           for(int j = 0; j < 8; j++){
	     printf("%02x ", config_data[i * 8 + j]);
           }
	   printf("\n");
        }

  printf("Free Heap Size 8bit = %d\r\n", heap_caps_get_free_size(MALLOC_CAP_8BIT));
  printf("Free Heap Size 32bit = %d\r\n", heap_caps_get_free_size(MALLOC_CAP_32BIT));

}



void app_main(void)
{

    ESP_LOGI(TAG, "[APP] Startup..");
    ESP_LOGI(TAG, "[APP] IDF version: %s", esp_get_idf_version());


    printf("Free Heap Size 8bit = %d\r\n", heap_caps_get_free_size(MALLOC_CAP_8BIT));
    printf("Free Heap Size 32bit = %d\r\n", heap_caps_get_free_size(MALLOC_CAP_32BIT));    
	i2c_master_init();
    ESP_ERROR_CHECK( nvs_flash_init() );
    initialise_wifi();
    sysinit();
    if ( xTaskCreate(&azure_task, "azure_task", 2048 * 5, NULL, 5, NULL) != pdPASS ) {
        printf("create azure task failed\r\n");
    }
}
